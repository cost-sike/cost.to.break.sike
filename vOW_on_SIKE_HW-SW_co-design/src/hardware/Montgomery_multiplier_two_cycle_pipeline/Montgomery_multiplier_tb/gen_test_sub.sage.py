
# This file was *autogenerated* from the file ../../Montgomery_multiplier_two_cycle_pipeline/Montgomery_multiplier_tb/gen_test_sub.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_610 = Integer(610); _sage_const_546 = Integer(546); _sage_const_4 = Integer(4); _sage_const_503 = Integer(503); _sage_const_23 = Integer(23); _sage_const_20 = Integer(20); _sage_const_697 = Integer(697); _sage_const_172 = Integer(172); _sage_const_215 = Integer(215); _sage_const_137 = Integer(137); _sage_const_117 = Integer(117); _sage_const_239 = Integer(239); _sage_const_159 = Integer(159); _sage_const_192 = Integer(192); _sage_const_191 = Integer(191); _sage_const_273 = Integer(273); _sage_const_216 = Integer(216); _sage_const_377 = Integer(377); _sage_const_448 = Integer(448); _sage_const_250 = Integer(250); _sage_const_372 = Integer(372); _sage_const_356 = Integer(356); _sage_const_16 = Integer(16); _sage_const_32 = Integer(32); _sage_const_128 = Integer(128); _sage_const_751 = Integer(751); _sage_const_434 = Integer(434); _sage_const_305 = Integer(305)# converted from Magma script

import sys
import argparse 

parser = argparse.ArgumentParser(description='Montgomery multiplication software.',
                formatter_class=argparse.ArgumentDefaultsHelpFormatter)

parser.add_argument('-w', '--w', dest='w', type=int, default=_sage_const_32 ,
          help='radix w')
parser.add_argument('-s', '--seed', dest='seed', type=int, required=False, default=None,
          help='seed')
parser.add_argument('-prime', '--prime', dest='prime', type=int, default=_sage_const_434 ,
          help='prime width')
parser.add_argument('-R', '--R', dest='R', type=int, default=_sage_const_448 ,
          help='rounded prime width')
args = parser.parse_args()

if args.seed:
  set_random_seed(args.seed)

# radix, can be 8, 16, 32, 64, etc, need to be careful about overflow 
w=args.w 
prime=args.prime
R=_sage_const_2 **(args.R) 

hex_format_element = "{0:0" + str(w/_sage_const_4 ) +"x}"
format_element = "{0:0" + str(w) +"b}"
format_carry = "{0:0" + str(w+_sage_const_1 ) +"b}"
format_CS = "{0:0" + str(_sage_const_2 *w+_sage_const_1 ) +"b}"

def bindigits(n, bits):
    s = bin(n & int("1"*bits, _sage_const_2 ))[_sage_const_2 :]
    return ("{0:0>%s}" % (bits)).format(s)

# pick a prime:
# testing purpose
if (prime == _sage_const_128 ): 
    p = _sage_const_2 **_sage_const_32 *_sage_const_3 **_sage_const_20 *_sage_const_23 -_sage_const_1 
elif (prime == _sage_const_377 ):
    p = _sage_const_2 **_sage_const_191 *_sage_const_3 **_sage_const_117 -_sage_const_1 
elif (prime == _sage_const_434 ): 
    p = _sage_const_2 **_sage_const_216 *_sage_const_3 **_sage_const_137 -_sage_const_1   
elif (prime == _sage_const_503 ):
    p = _sage_const_2 **_sage_const_250 *_sage_const_3 **_sage_const_159 -_sage_const_1  
elif (prime == _sage_const_610 ):
    p = _sage_const_2 **_sage_const_305 *_sage_const_3 **_sage_const_192 -_sage_const_1 
elif (prime == _sage_const_751 ):
    p = _sage_const_2 **_sage_const_372 *_sage_const_3 **_sage_const_239 -_sage_const_1  
elif (prime == _sage_const_546 ):
    p = _sage_const_2 **_sage_const_273 *_sage_const_3 **_sage_const_172 -_sage_const_1 
elif (prime == _sage_const_697 ):
    p = _sage_const_2 **_sage_const_356 *_sage_const_3 **_sage_const_215 -_sage_const_1  
else:
  print "Error!!\n\n  Please specify a valid value for prime p!\n"


# Finite field
Fp = GF(p)
 
# number of digits in operands a and b
n = int(log(R,_sage_const_2 )/w)
#n_32 = int(log(R,2)/32)
#w_32 = 32
n_32 = n
w_32 = w

# force unsigned arithmetic
Z = IntegerRing()
Fr = IntegerModRing(R)
pp = Fr(-p**-_sage_const_1 )
assert((pp % _sage_const_2 **w) == _sage_const_1 )

OK=true

for k in range(_sage_const_2 ):
    oa0 = [Z(_sage_const_0 )]*n
    ob0 = [Z(_sage_const_0 )]*n
    oa1 = [Z(_sage_const_0 )]*n
    ob1 = [Z(_sage_const_0 )]*n 

    a0 = Z(_sage_const_0 )
    b0 = Z(_sage_const_0 )
    a1 = Z(_sage_const_0 )
    b1 = Z(_sage_const_0 )

    # read in a_0
    with open("mem_0_a_0.txt") as file_in:
        lines = []
        for line in file_in:
            lines.append(line)
    file_in.close()

    for i in range(n_32):
        x = Z(int(lines[i], _sage_const_16 )) 
        a0 += Z(x*_sage_const_2 **(w_32*i)) 
    
    # read in a_1
    with open("mem_0_a_1.txt") as file_in:
        lines = []
        for line in file_in:
            lines.append(line)
    file_in.close()
    
    for i in range(n_32):
        x = Z(int(lines[i], _sage_const_16 )) 
        a1 += x*_sage_const_2 **(w_32*i)
    
    # read in b_0
    with open("mem_0_b_0.txt") as file_in:
        lines = []
        for line in file_in:
            lines.append(line)
    file_in.close()

    for i in range(n_32):
        x = Z(int(lines[i], _sage_const_16 ))
        b0 += x*_sage_const_2 **(w_32*i)

    # read in b_1
    with open("mem_0_b_1.txt") as file_in:
        lines = []
        for line in file_in:
            lines.append(line)
    file_in.close()

    for i in range(n_32):
        x = Z(int(lines[i], _sage_const_16 ))
        b1 += x*_sage_const_2 **(w_32*i)


    f_a_0 = open("mult_" + str(k) + "_a_0" + ".txt", "w");
    f_a_1 = open("mult_" + str(k) + "_a_1" + ".txt", "w");
    f_b_0 = open("mult_" + str(k) + "_b_0" + ".txt", "w");
    f_b_1 = open("mult_" + str(k) + "_b_1" + ".txt", "w");
    
    # direct result, for comparison
    c = Fp(a0*b0-a1*b1) 
    
    # main algorithm: integrated multi-precision multiplication and Montgomery reduction
    # algorithm in operand scanning form - FIOS (schoolbook)
    # compute MontRed(a0*b0-a1*b1)
    # preliminaries
    m = [Z(_sage_const_0 )]*n

    f_c_1 = open("mem_c_1.mem", "w");  

    for i in range(n):
        m[i] = ((p+_sage_const_1 ) >> (w*i)) % _sage_const_2 **w
        f_c_1.write(format_element.format(m[i]))
        f_c_1.write("\n")
    
    oa0 = [Z(_sage_const_0 )]*n
    ob0 = [Z(_sage_const_0 )]*n
    oa1 = [Z(_sage_const_0 )]*n
    ob1 = [Z(_sage_const_0 )]*n
    
    for i in range(n):  
        oa0[i] = Z((Z(a0) >> (w*i)) % _sage_const_2 **w) 
        f_a_0.write(hex_format_element.format(oa0[i]))
        f_a_0.write("\n")
        ob0[i] = Z((Z(b0) >> (w*i)) % _sage_const_2 **w) 
        f_b_0.write(hex_format_element.format(ob0[i]))
        f_b_0.write("\n")
        oa1[i] = Z((Z(a1) >> (w*i)) % _sage_const_2 **w)
        f_a_1.write(hex_format_element.format(oa1[i]))
        f_a_1.write("\n")
        ob1[i] = Z((Z(b1) >> (w*i)) % _sage_const_2 **w)
        f_b_1.write(hex_format_element.format(ob1[i]))
        f_b_1.write("\n")
   
    f_a_0.close()
    f_a_1.close()
    f_b_0.close()
    f_b_1.close()
    f_c_1.close()
    
    # actual Montgomery multiplication algorithm
    # CS = (C, S), C is (w+1)-bits, and S is w bits. C gets sign-extended for addition in the inner j loop
    t = [Z(_sage_const_0 )]*n
    f_res = open("mult_" + str(k) + "_res_sage" + ".txt", "w")
    f_sum = open("mult_" + str(k) + "_sum_sage" + ".txt", "w")
    f_carry = open("mult_" + str(k) + "_carry_sage" + ".txt", "w")
    f_CS = open("mult_" + str(k) + "_CS_sage" + ".txt", "w")

    for i in range(n):
        CS = oa0[_sage_const_0 ]*ob0[i] - oa1[_sage_const_0 ]*ob1[i] + t[_sage_const_0 ]  
        f_CS.write(bindigits(CS, _sage_const_2 *w+_sage_const_2 ))
        f_CS.write("\n")
        S = CS % _sage_const_2 **w
        C = CS >> w
        f_sum.write(format_element.format(S))
        f_sum.write("\n") 
        f_carry.write(bindigits(C, w+_sage_const_2 ))
        f_carry.write("\n")
        mm = S
        for j in range(_sage_const_1 , n):
            CS = oa0[j]*ob0[i] - oa1[j]*ob1[i] + mm*m[j] + t[j] + C  
            f_CS.write(bindigits(CS, _sage_const_2 *w+_sage_const_2 ))
            f_CS.write("\n")
            S = CS % _sage_const_2 **w
            C = CS >> w
            t[j-_sage_const_1 ] = S
            f_sum.write(format_element.format(S))
            f_sum.write("\n") 
            f_carry.write(bindigits(C, w+_sage_const_2 ))
            f_carry.write("\n")
        t[n-_sage_const_1 ] = C  
    
    f_sum.close()
    f_carry.close()
    f_CS.close()
  
    # Assembling result, not needed in hw
    e = _sage_const_0 
    for i in range(n):
        e += t[i]*_sage_const_2 **(w*i)
    
    # final correction to positive
    if (e < _sage_const_0 ):
        print "\nresult e is SMALLER than 0!\n"
        e += _sage_const_2 *p
    
    assert(e >= _sage_const_0 )

    oe = [Z(_sage_const_0 )]*n

    for i in range(n):
        oe[i] = Z((Z(e) >> (w*i)) % _sage_const_2 **w)
        f_res.write(hex_format_element.format(oe[i]))
        f_res.write("\n")

    f_res.close()
    
    if (e > p):
        e -= p
    
    # conversion to standard form
    e = Fp(e*R)
    
    # verification of results
    if (Z(c) != Z(e)):
        OK = false
        break
 

if OK:
    print "Sage Software Verification Result:"
    print "    PASSED"
    print "\n"
else:
    print "FAILED"
    print "\n"

# write value 2*p to a file
t = _sage_const_2 *p

ot = [Z(_sage_const_0 )]*n 

f_t = open("px2.mem", "w"); 

for i in range(n):  
    ot[i] = Z((Z(t) >> (w*i)) % _sage_const_2 **w) 
    f_t.write(format_element.format(ot[i]))
    f_t.write("\n") 

f_t.close()

